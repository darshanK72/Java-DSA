/**
 * Problem Statement:
 * 
 *     The "Count and Say" sequence is a sequence of digit strings defined by the following rules:
 *     - The sequence begins with "1".
 *     - Each subsequent term is derived from the previous term by reading off the digits of the previous term, 
 *       grouping the same digits together, and counting how many times each digit appears consecutively.
 * 
 *     For example:
 *     - 1st term: "1"
 *     - 2nd term: "11" (one "1")
 *     - 3rd term: "21" (two "1"s)
 *     - 4th term: "1211" (one "2", one "1")
 *     - 5th term: "111221" (one "1", one "2", two "1"s)
 *     - And so on...
 * 
 * Input:
 *     - An integer `n` (1 <= n <= 30), representing the term of the sequence to generate.
 * 
 * Output:
 *     - The nth term of the "Count and Say" sequence.
 * 
 * Example:
 *     Input:
 *     4
 *     Output:
 *     "1211"
 * 
 *     Explanation:
 *     The 4th term in the sequence is "1211", which is generated from the 3rd term "21".
 *     The term "21" is read as "one 2, one 1", so the 4th term is "1211".
 */

import java.util.Scanner;

public class j02CountAndSay {

    public static void main(String args[]) {
        // Reading input
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(); // Input: the term of the sequence to generate
        System.out.println(countAndSay(n)); // Call to the countAndSay function
        in.close();
    }

    /**
     * Approach: Iterative Generation of "Count and Say" Sequence
     * 
     * Intuition:
     * - We start with the base string "1" and iteratively generate the next term by applying the 
     *   "count and say" operation on the current term.
     * - For each term, we group consecutive characters, count the occurrences of each group, 
     *   and append the result (count followed by the character).
     * - This process continues for `n` terms.
     * 
     * Time Complexity:
     * - O(n * m), where `n` is the number of terms to generate and `m` is the average length of the terms.
     *   In the worst case, `m` can grow exponentially, but since `n <= 30`, this is manageable.
     * 
     * Space Complexity:
     * - O(m), where `m` is the length of the current term being generated.
     * 
     * @param n The term of the sequence to generate.
     * @return The nth term of the "Count and Say" sequence.
     */
    public static String countAndSay(int n) {
        StringBuilder out = new StringBuilder("1"); // Start with the first term
        for (int i = 2; i <= n; i++) {
            out = runLengthEncoding(out); // Generate the next term by applying run-length encoding
        }
        return out.toString(); // Return the nth term
    }

    /**
     * Helper Function: Run-Length Encoding for a StringBuilder
     * 
     * Intuition:
     * - This function takes a string and counts consecutive characters. For each group of consecutive 
     *   characters, it appends the count followed by the character to a new string.
     * 
     * Time Complexity:
     * - O(m), where `m` is the length of the input string, since we process each character once.
     * 
     * Space Complexity:
     * - O(m), where `m` is the length of the output string.
     * 
     * @param n The current term of the sequence.
     * @return The next term generated by "count and say".
     */
    public static StringBuilder runLengthEncoding(StringBuilder n) {
        StringBuilder out = new StringBuilder(); // To store the result
        for (int i = 0; i < n.length(); i++) {
            int j = i;
            int c = 0; // To count the consecutive characters
            while (j < n.length() && n.charAt(i) == n.charAt(j)) {
                j++; // Increment index while characters are the same
                c++; // Increment count of consecutive characters
            }
            j--; // Adjust index for next character
            out.append(c).append(n.charAt(j)); // Append count followed by the character
            i = j; // Move to the next new character
        }
        return out; // Return the next term
    }
}

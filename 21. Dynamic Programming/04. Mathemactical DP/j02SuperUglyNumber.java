/**
 * LeetCode 313. Super Ugly Number
 * 
 * Problem Statement:
 *     A super ugly number is a positive integer whose prime factors are in the
 *     array primes. Given an integer n and an array of integers primes, return
 *     the nth super ugly number. Super ugly numbers are positive numbers whose
 *     all prime factors are in the given array primes.
 * 
 * Input:
 *     - n (1 <= n <= 10^6) - the position of the super ugly number to find
 *     - primes (1 <= primes.length <= 100, 2 <= primes[i] <= 1000) - array of
 *       prime factors
 * 
 * Output:
 *     - Integer representing the nth super ugly number
 * 
 * Example:
 *     Input: n = 12, primes = [2,7,13,19]
 *     Output: 32
 * 
 *     Explanation:
 *     [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super
 *     ugly numbers given primes = [2,7,13,19].
 * 
 * Note:
 *     1 is typically considered a super ugly number for any given primes array.
 */

import java.util.ArrayList;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Set;

public class j02SuperUglyNumber {

     /**
     * Approach 1: Priority Queue with HashSet (Alternative)
     * 
     * Intuition:
     * - Use a min heap to always get the smallest super ugly number available
     * - Start with 1 and generate new super ugly numbers by multiplying with
     *   each prime factor
     * - Use a HashSet to avoid duplicates and track processed numbers
     * - Extract the nth smallest number from the heap
     * 
     * Explanation:
     * - Initialize min heap with 1 (first super ugly number)
     * - While we haven't found n super ugly numbers:
     *   - Extract minimum from heap
     *   - Add it to result set if not already processed
     *   - Generate new super ugly numbers by multiplying with each prime
     *   - Add new numbers to heap if not already present
     * - Return the nth super ugly number
     * 
     * Time Complexity: O(n * k * log(n)) - Each number processed once, heap operations
     * Space Complexity: O(n) - Heap and HashSet to store super ugly numbers
     * 
     * @param n       Position of super ugly number to find (1 <= n <= 10^6)
     * @param primes  Array of prime factors (1 <= primes.length <= 100)
     * @return        The nth super ugly number
     */
    public static int nthSuperUglyPriorityQueue(int n, int[] primes) {
        // Handle edge cases
        if (n <= 0 || primes == null || primes.length == 0) {
            return 0;
        }
        
        // Initialize min heap to always get smallest super ugly number
        PriorityQueue<Long> pq = new PriorityQueue<>();  // Use Long to avoid overflow
        pq.add(1L);  // Start with first super ugly number
        
        // Track processed numbers to avoid duplicates
        Set<Long> processed = new HashSet<>();
        long currentUgly = 1;
        
        // Generate super ugly numbers until we find the nth one
        while (processed.size() < n) {
            // Extract smallest super ugly number from heap
            currentUgly = pq.poll();
            
            // Add to processed set if not already seen
            if (!processed.contains(currentUgly)) {
                processed.add(currentUgly);
                
                // Generate new super ugly numbers by multiplying with each prime
                for (int i = 0; i < primes.length; i++) {
                    long newUgly = currentUgly * primes[i];
                    // Check for overflow and avoid adding if already processed
                    if (newUgly > 0 && !processed.contains(newUgly)) {
                        pq.add(newUgly);
                    }
                }
            }
        }
        
        return (int) currentUgly;
    }
    
    /**
     * Approach 2: Multiple Pointers (Dynamic Programming)
     * 
     * Intuition:
     * - Similar to Ugly Number II, but instead of just 2, 3, 5, we have multiple
     *   prime factors from the primes array
     * - Use multiple pointers (one for each prime) to track the next super ugly
     *   number that can be generated by multiplying with each prime
     * - Always choose the minimum of all possible next super ugly numbers
     * - This ensures we generate super ugly numbers in sorted order
     * 
     * Explanation:
     * - Initialize an array of pointers, one for each prime factor
     * - Start with super ugly numbers list containing [1]
     * - For each iteration:
     *   - Calculate next super ugly numbers: list[ptr[i]] * primes[i] for each i
     *   - Choose minimum as next super ugly number
     *   - Add it to the list
     *   - Increment pointers that generated the chosen number
     * - Return the nth super ugly number
     * 
     * Time Complexity: O(n * k) where n is the target number and k is primes.length
     * Space Complexity: O(n) - List to store super ugly numbers
     * 
     * @param n       Position of super ugly number to find (1 <= n <= 10^6)
     * @param primes  Array of prime factors (1 <= primes.length <= 100)
     * @return        The nth super ugly number
     */
    public static int nthSuperUglyNumber(int n, int[] primes) {
        // Handle edge cases
        if (n <= 0 || primes == null || primes.length == 0) {
            return 0;
        }
        
        // Initialize array of pointers, one for each prime factor
        int[] pointers = new int[primes.length];
        
        // List to store super ugly numbers in sorted order
        ArrayList<Integer> superUglyNumbers = new ArrayList<>();
        superUglyNumbers.add(1);  // First super ugly number
        
        // Generate super ugly numbers until we have n numbers
        while (superUglyNumbers.size() < n) {
            // Calculate next possible super ugly numbers for each prime
            long nextUgly = Long.MAX_VALUE;  // Use long to avoid overflow
            
            // Find the minimum among all possible next super ugly numbers
            for (int i = 0; i < primes.length; i++) {
                long candidate = (long) superUglyNumbers.get(pointers[i]) * primes[i];
                nextUgly = Math.min(nextUgly, candidate);
            }
            
            // Add the minimum to our list
            superUglyNumbers.add((int) nextUgly);
            
            // Increment pointers that generated the chosen number
            for (int i = 0; i < primes.length; i++) {
                long candidate = (long) superUglyNumbers.get(pointers[i]) * primes[i];
                if (nextUgly == candidate) {
                    pointers[i]++;
                }
            }
        }
        
        return superUglyNumbers.get(n - 1);
    }
    
    /**
     * Approach 3: Space-Optimized Multiple Pointers
     * 
     * Intuition:
     * - Similar to Approach 1 but use an array instead of ArrayList
     * - Pre-allocate array of size n to avoid dynamic resizing
     * - More memory efficient and slightly faster
     * 
     * Explanation:
     * - Initialize array of size n and multiple pointers
     * - Fill array with super ugly numbers using same logic as Approach 1
     * - Return the nth element directly from array
     * 
     * Time Complexity: O(n * k) where n is the target number and k is primes.length
     * Space Complexity: O(n) - Array to store super ugly numbers
     * 
     * @param n       Position of super ugly number to find (1 <= n <= 10^6)
     * @param primes  Array of prime factors (1 <= primes.length <= 100)
     * @return        The nth super ugly number
     */
    public static int nthSuperUglyNumberOptimized(int n, int[] primes) {
        // Handle edge cases
        if (n <= 0 || primes == null || primes.length == 0) {
            return 0;
        }
        
        // Pre-allocate array for better performance
        int[] superUglyNumbers = new int[n];
        superUglyNumbers[0] = 1;  // First super ugly number
        
        // Initialize array of pointers, one for each prime factor
        int[] pointers = new int[primes.length];
        
        // Generate super ugly numbers
        for (int i = 1; i < n; i++) {
            // Calculate next possible super ugly numbers for each prime
            long nextUgly = Long.MAX_VALUE;  // Use long to avoid overflow
            
            // Find the minimum among all possible next super ugly numbers
            for (int j = 0; j < primes.length; j++) {
                long candidate = (long) superUglyNumbers[pointers[j]] * primes[j];
                nextUgly = Math.min(nextUgly, candidate);
            }
            
            // Add the minimum to our array
            superUglyNumbers[i] = (int) nextUgly;
            
            // Increment pointers that generated the chosen number
            for (int j = 0; j < primes.length; j++) {
                long candidate = (long) superUglyNumbers[pointers[j]] * primes[j];
                if (nextUgly == candidate) {
                    pointers[j]++;
                }
            }
        }
        
        return superUglyNumbers[n - 1];
    }

    public static void main(String[] args) {
        // Test Case 1: Basic cases
        System.out.println("\nBasic Test Cases:");
        int[] primes1 = {2, 7, 13, 19};
        System.out.println("Input: n=12, primes=[2,7,13,19], Expected: 32, Output: " + nthSuperUglyNumber(12, primes1));
        
        int[] primes2 = {2, 3, 5};
        System.out.println("Input: n=10, primes=[2,3,5], Expected: 12, Output: " + nthSuperUglyNumber(10, primes2));

        // Test Case 2: Edge cases
        System.out.println("\nEdge Cases:");
        System.out.println("Input: n=1, primes=[2,3,5], Expected: 1, Output: " + nthSuperUglyNumber(1, primes2));
        System.out.println("Input: n=2, primes=[2,3,5], Expected: 2, Output: " + nthSuperUglyNumber(2, primes2));

        // Test Case 3: Large input (the failing test case)
        System.out.println("\nLarge Input Test (Failing Test Case):");
        int[] primes3 = {2, 3, 5, 7};
        int n = 5911;
        System.out.println("Input: n=" + n + ", primes=[2,3,5,7]");
        System.out.println("Expected: 2144153025");
        System.out.println("Output: " + nthSuperUglyNumber(n, primes3));
        System.out.println("Optimized Output: " + nthSuperUglyNumberOptimized(n, primes3));

        // Test Case 4: Compare approaches
        System.out.println("\nComparing Approaches:");
        int[] primes4 = {2, 3, 5, 7};
        n = 100;
        System.out.println("Input: n=" + n + ", primes=[2,3,5,7]");
        System.out.println("Multiple Pointers: " + nthSuperUglyNumber(n, primes4));
        System.out.println("Optimized: " + nthSuperUglyNumberOptimized(n, primes4));

        // Test Case 5: Different prime sets
        System.out.println("\nDifferent Prime Sets:");
        int[] primes5 = {2, 3, 5, 7, 11};
        System.out.println("Input: n=20, primes=[2,3,5,7,11], Output: " + nthSuperUglyNumber(20, primes5));
        
        int[] primes6 = {2, 3};
        System.out.println("Input: n=15, primes=[2,3], Output: " + nthSuperUglyNumber(15, primes6));
        
        // Test Case 6: First few super ugly numbers
        System.out.println("\nFirst 15 Super Ugly Numbers with primes=[2,3,5,7]:");
        for (int i = 1; i <= 15; i++) {
            System.out.print(nthSuperUglyNumber(i, primes3) + " ");
        }
        System.out.println();
    }
}
